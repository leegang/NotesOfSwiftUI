# 1. 步进器Stepper, DatePicker, DateFormatter基础
<!-- TOC -->

- [1. 步进器Stepper, DatePicker, DateFormatter基础](#1-步进器stepper-datepicker-dateformatter基础)
    - [1.1. 用步进器输入数值](#11-用步进器输入数值)
    - [1.2. 使用DatePicker选择日期和时间](#12-使用datepicker选择日期和时间)
    - [1.3. 处理日期](#13-处理日期)
    - [1.4. 使用Create ML训练模型](#14-使用create-ml训练模型)

<!-- /TOC -->

## 1.1. 用步进器输入数值

SwiftUI有两种让用户输入数字的方式，而我们将在这里使用的一种是步进器：一个简单的`-`和`+`按钮，可以点击来选择一个精确的数字。 另一个选择是`Slider`，我们稍后将使用它，它也使我们可以从一系列值中进行选择，但不太精确。

步进器非常聪明，可以处理您喜欢的任何类型的数字类型–您可以将它们绑定到`Int`，`Double`和更多类型，它将自动适应。 例如，我们可以创建如下属性：

```swift
@State private var sleepAmount = 8.0
```

然后我们可以把它绑定到一个步进器上，这样它就会显示当前值，就像这样:

```swift
Stepper(value: $sleepAmount) {
    Text("\(sleepAmount) hours")
}
```

当这段代码运行时，您将看到8.000000小时，您可以点击- 或 +，向下到7、6、5并进入负数，或者向上到9、10、11，等等。

默认情况下，步进器仅受其存储范围的限制。 在此示例中，我们使用Double，这意味着滑块的最大值将为1.7976931348623157e + 308。 这是科学计数法，它的意思是“ 1.79769乘以10的308的幂” 。更简单地说，这确实是一个非常大的数字。

现在，作为两个孩子的父亲，你不知道我有多爱睡觉，尽管我也睡不好。幸运的是，Stepper允许我们通过提供一个`in`范围来限制我们想要接受的值，就像这样，想睡几小时就睡几小时:

```swift
Stepper(value: $sleepAmount, in: 4...12) {
    Text("\(sleepAmount) hours")
}
```

有了这个改动，步进器将从8开始，然后允许用户在4和12之间移动，但不能超过这个范围。这允许我们控制睡眠范围，使用户不能尝试24小时睡眠，也让我们拒绝不可能的值，例如你不能睡-1小时。

还有第三个有用的步进参数`Stetpper`，即步进值—每次—或+移动值的距离`step`。同样，这可以是任何类型的数字，但它需要匹配用于绑定的类型。因此，如果绑定到整数，则不能使用Double作为步骤值。

在这种情况下，我们可能会说，用户可以选择4到12之间的任何睡眠值，以15分钟的增量移动:

```swift
Stepper(value: $sleepAmount, in: 4...12, step: 0.25) {
    Text("\(sleepAmount) hours")
}
```

这开始看起来很有用-我们拥有合理范围的精确值，合理的步长增量，并且用户每次都能准确看到他们选择的内容。

不过，在继续之前，请先解决该问题：现在显示为8.000000，虽然准确，但太长了。之前我们使用过这样的字符串插值说明符:

```swift
Text("\(sleepAmount, specifier: "%.2f") hours")
```

我们可以在这里使用它，但看起来很奇怪：“ 8.00小时”似乎过于学术。 这是“％g”说明符在起作用的一个很好的例子，因为它会自动从数字末尾删除不重要的零。 因此，它将显示8、8.25、8.5、8.75、9，依此类推，用户阅读起来自然得多。

## 1.2. 使用DatePicker选择日期和时间

SwiftUI为我们提供了一种称为`DatePicker`的专用选择器类型，可以将它绑定到`date`属性。 是的，Swift具有专用于处理日期的类型，它被称为`date`。

因此，要使用它，您首先需要使用`@State`属性，例如：

```swift
@State private var wakeUp = Date()
```

然后，您可以将其绑定到日期选择器，如下所示：

```swift
var body: some View {
    DatePicker("Please enter a date", selection: $wakeUp)
}
```

尝试在模拟器中运行它，以便查看外观。 您应该看到带有日期和时间的滚轮，以及左侧的“Please enter a date”标签。

现在，您可能会认为该标签看起来很丑陋，尝试用以下标签替换它：

```swift
DatePicker("", selection: $wakeUp)
```

但是，如果这样做，您将遇到两个问题：日期选择器即使标签为空也仍然为标签留出空间，并且屏幕阅读器处于活动状态的用户（他们更熟悉VoiceOver）将不知道日期是为什么而选择器。

有两种选择，都可以解决问题。

第一，我们可以将`DatePicker`包装为一个`Form`：

```swift
var body: some View {
    Form {
        DatePicker("Please enter a date", selection: $wakeUp)
    }
}
```

就像常规的选择器一样，这会改变SwiftUI渲染视图的方式。 不过，这次我们没有将新视图推送到`NavigationView`上； 取而代之的是，我们得到一个列表行，当点击它时它会折叠成日期选择器。

这看起来非常好，并且将表单的简洁性与日期选择器的熟悉的，基于转轮的用户界面相结合。 可悲的是，现在这些选择器的显示方式有时会出现一些故障。 我们稍后再讲。

除了使用表单`Form`之外，另一种方法是使用`labelsHidden（）`修饰符，如下所示：

```swift
var body: some View {
    DatePicker("Please enter a date", selection: $wakeUp)
        .labelsHidden()
}
```

该标签仍包含原始标签，因此屏幕阅读器可以将其用于VoiceOver，但是现在它们在屏幕上不再可见-日期选择器将占据屏幕上的所有水平空间。

日期选择器为我们提供了几个配置选项，以控制它们的工作方式。 首先，我们可以使用`displayComponents`来决定用户应该看到的选项类型：

- 如果您不提供此参数，则用户会看到一天，一小时和一分钟。
- 如果使用`.date`，则用户可以查看月，日和年。
- 如果使用`.hourAndMinute`，则用户只会看到小时和分钟部分。

因此，我们可以选择这样的精确时间：

```swift
DatePicker("Please enter a time", selection: $wakeUp, displayedComponents: .hourAndMinute)
```

最后，有一个`in`参数与在`Stepper`中的的工作原理相同：我们可以为它提供一个日期范围，并且日期选择器将确保用户不能选择超出范围。

现在，我们已经使用一段时间了，您已经习惯看到`1 ... 5`或`0 .. <10` 之类的东西，但是我们也可以将Swift日期与范围一起使用。 例如：

```swift
// when you create a new Date instance it will be set to the current date and time
let now = Date()

// create a second Date instance set to one day in seconds from now
let tomorrow = Date().addingTimeInterval(86400)

// create a range from those two
let range = now ... tomorrow
```

 译者注：上述方法需要放在`var body`里面，否则会报错`Cannot use instance member 'now' within property initializer; property initializers run before 'self' is available`

这对于DatePicker确实有用，但还有更好的地方：我们指定起始或结束范围,但不同时指定两个范围。Swift会形成一个单边范围，而另一边由Swift推断。

例如，我们可以这样创建一个日期选择器：

```swift
DatePicker("Please enter a date", selection: $wakeUp, in: Date()...)
```

这将允许将来的所有日期，但不允许过去的所有日期。读作“从当前日期到任何日期”。

## 1.3. 处理日期

让用户输入日期就像将类型为`Date`的`@State`属性绑定到`DatePicker` SwiftUI控件一样容易，但是之后事情会变得更加复杂。

您会发现，处理日期非常困难,真的很难。 比您想象的要难得多。比我想象的要难得多，而且我已经有很多年经验了。

看一下这个简单的例子：

```swift
let now = Date()
let tomorrow = Date().addingTimeInterval(86400)
let range = now ... tomorrow
```

这将创建一个从现在（`Date（）`是当前日期）到明天同一时间（86400是一天中的秒数）的范围。

这看起来似乎很容易，但是整天有86,400秒吗？如果这样做的话，很多人将失业！想想夏令时制：有时时钟前进（丢失一个小时），有时倒退（获得一个小时），这意味着那一天我们可能有23或25个小时。然后是`闰秒`：为了适应地球的慢转而增加的时间。

如果您认为这很困难，请尝试在Mac终端上运行此程序：cal。这会打印出当月的简单日历，向您显示星期几。现在尝试运行9 1752日历，向您显示1752年9月的日历–由于日历从朱利安（Julian）到格里高利（Gregorian）的日历，您会发现整整12天都没有了。

现在，我之所以这么说并不是为了吓唬你-毕竟在我们的程序中日期是不可避免的。相反，我希望您理解对于任何重要的事情-在代码中实际使用的日期的重要使用-我们都应依靠Apple的框架进行计算和格式化。

在项目中，我们将通过三种方式使用日期：

- 选择一个合理的默认“唤醒”时间。
- 读取他们想醒来的小时和分钟。
- 显示建议他们的就寝时间。

如果需要，我们可以手动完成所有操作，但是您将进入夏时制，leap秒和公历日历领域。

最好让iOS为我们完成所有艰苦的工作：工作量少得多，而且无论用户的区域设置如何，都可以保证它是正确的。

让我们从选择合理的唤醒时间开始，逐一解决每个问题。

如您所见，Swift为我们提供了使用日期的日期，并封装了年，月，日，时，分，秒，时区等。但是，我们不想考虑其中的大部分-我们想说“给我早上8点的起床时间，无论今天是星期几。”

Swift为此有一种略有不同的类型，称为`DateComponents`，它使我们可以读取或写入日期的特定部分而不是整个内容。

因此，如果我们想要一个表示今天上午8点的日期，我们可以编写如下代码：

```swift
var components = DateComponents()
components.hour = 8
components.minute = 0
let date = Calendar.current.date(from: components)
```

现在，由于日期验证方面的困难，`date(from:)`方法实际上返回一个可选的日期，所以最好使用nil合并来表示“如果失败了，就返回当前日期”，就像这样:

```swift
let date = Calendar.current.date(from: components) ?? Date()
```

第二个挑战是，我们如何知道他们想醒来的时间。请记住，`DatePicker`绑定到一个提供大量信息的日期，因此我们需要找到一种方法来提取小时和分钟组件。

再一次，`DateComponents`发挥了作用:我们可以要求iOS提供来自日期的特定组件，然后将它们读出来。一个小问题是，由于`DateComponents`的工作方式，我们请求的值和获得的值之间存在脱节:我们可以请求小时和分钟，但是我们将返回一个DateComponents实例，其中包含所有属性的可选值。是的，我们知道会有hour和minute，因为这些是我们要求的，但是我们仍然需要打开选项或提供默认值。

所以，我们可以这样写代码:

```swift
let components = Calendar.current.dateComponents([.hour, .minute], from: someDate)
let hour = components.hour ?? 0
let minute = components.minute ?? 0
```

最后一个挑战是我们如何格式化日期和时间，Swift再一次为我们提供了一个特定的类型来完成大部分工作。这次它被称为`DateFormatter`，它允许我们用多种方式将日期转换成字符串。

例如，如果我们只是想知道日期的时间，我们可以这样写:

```swift
let formatter = DateFormatter()
formatter.timeStyle = .short
let dateString = formatter.string(from: Date())
```

我们还可以设置`.dateStyle`来获取日期值，甚至可以使用`dateFormat`传递完全定制的格式，但这超出了本项目的范围!

问题是，日期很难，但苹果为我们提供了大量的帮助，让日期变得不那么难。如果你能很好地使用它们，你就能写更少的代码，也能写更好的代码!

## 1.4. 使用Create ML训练模型

在iOS 11中，设备上机器学习已从“极度困难”变为“非常可能，而且功能强大”，这要归功于一个苹果框架：`Core ML`。一年后，Apple引入了另一个名为`Create ML`的框架，该框架在使机器学习“易于执行”，然后第二年之后，Apple引入了`Create ML`应用程序，该应用程序让整个过程拖拽进行。由于所有这些工作，现在任何人都可以将机器学习添加到他们的应用程序中。

`Core ML`能够处理各种训练任务，例如识别图像，声音甚至运动，但是在这种情况下，我们将研究表格回归。这是一个花哨的名字，在机器学习中很常见，但它的真正含义是我们可以在Create ML上放置大量类似于电子表格的数据，并要求它找出各种值之间的关系。

机器学习分两步完成：我们训练模型，然后让模型进行预测。训练是计算机查看我们所有数据以找出我们拥有的所有值之间的关系的过程，而在大型数据集中，这可能需要很长时间-轻松几个小时，甚至可能更长。预测是在设备上完成的：我们将训练后的模型提供给它，它将使用以前的结果对新数据进行估算。

现在开始培训过程：请在Mac上打开“Create ML”应用。如果您不知道它在哪里，可以通过Xcode菜单并选择Open Developer Tool> Create ML从Xcode启动它。

Create ML应用程序要做的第一件事是要求您创建一个项目或打开一个上一个项目–请单击“新建文档”以开始使用。您会看到有很多模板可供选择，但是如果向下滚动到底部，则会看到Tabular Regressor；请选择该选项，然后按Next。对于项目名称，请输入BetterRest，然后按Next，选择您的桌面，然后按Create。

首先，在这里创建ML似乎有些棘手，因为您会看到一个包含很多选项的屏幕。不过请放心，一旦我逐步引导您，就不会那么难。

第一步是向Create ML提供一些训练数据。这是要查看的原始统计数据，在我们的案例中，该统计数据包含四个值：当某人想要醒来时，他们认为自己希望拥有多少睡眠，每天喝多少咖啡，以及他们多少睡眠实际需要。

我已经在BetterRest.csv中为您提供了此数据，该文件位于该项目的项目文件中。这是Create ML可以使用的逗号分隔值数据集，我们的第一项工作是导入它。

因此，在“创建ML”中，在“数据输入”下查找，然后在“培训数据”标题下选择“选择”。当您按Select File时，它将打开一个文件选择窗口，您应该选择BetterRest.csv。

重要提示：此CSV文件包含用于此项目的示例数据，不应将其用于与健康相关的实际工作。

下一步是确定目标，这是我们希望计算机学习预测的值，而功能是我们希望计算机检查以预测目标的值。例如，如果我们选择某人认为需要多少睡眠和实际需要多少睡眠作为功能，我们可以训练计算机以预测他们喝了多少咖啡。

在这种情况下，我希望您为目标选择“ actualSleep”，这意味着我们希望计算机学习如何预测他们实际需要多少睡眠时间。现在，按“选择功能”，然后选择所有三个选项：“唤醒”，“估计睡眠”和“咖啡” –我们希望计算机在生成预测时将所有这三个因素都考虑在内。

“选择功能”按钮下面是该算法的下拉按钮，有五个选项：“自动”，“随机森林”，“增强树”，“决策树”和“线性回归”。每种方法都采用不同的方法来分析数据，尽管这不是一本有关机器学习的书，但我还是想简要解释一下它们的作用。

线性回归是最容易理解的，因为它几乎完全是我们大脑的工作方式。它们试图通过将变量视为线性函数（例如applyAlgorithm（var1，var2，var3））的一部分来估计变量之间的关系。线性回归的目标是能够在所有数据点上绘制一条直线，其中直线与每个数据点之间的平均距离应尽可能小。

决策树回归器形成自然的树状结构，使我们可以将信息组织为一系列选择。试着设想这几乎就像一个有20个问题的游戏：“您是人还是动物？如果您是一个人，您是活着还是死了？依此类推–每次树可以根据每个问题的答案而分支出来，直到最终有了一个确定的答案。

增强树回归使用一系列决策树进行工作，其中每棵树都被设计用来纠正前一棵树中的任何错误。例如，第一个决策树采用最佳猜测来找到一个好的预测，但是它偏离了20%。然后将其传递给第二个决策树进行进一步细化，并重复这个过程——不过，这一次，错误降低到了10%。第三棵树的误差降到8%第四棵树的误差降到7%

随机森林模型类似于增强树，但有一点不同:使用增强树时，树中的每个决策都可以访问所有可用数据，而使用随机树时，每棵树只能访问数据的一个子集。

这听起来可能很奇怪:为什么要保留数据?想象一下，你正面临一个编码问题，并试图找出一个解决方案。如果你向同事征求意见，他们会根据他们所知道的给你一些。如果你向不同的同事征求意见，他们很可能会根据他们的知识给你不同的意见。如果你向100位同事征求意见，你会得到一系列的解决方案。

你的每个同事都有不同的背景，不同的教育背景，不同的工作经历，这就是为什么你会得到一系列的建议。但是如果你把每个人的建议平均起来——不管大多数人说什么，不管是什么导致他们做出这个决定——你就最有可能找到正确的解决方案。

这正是随机森林回归的工作方式:每棵决策树都有自己的数据视图，与其他树不同，通过将所有预测组合在一起，得出一个平均值，你就有很大的机会得到一个强有力的结果。

有益的是，有一个自动选项试图自动选择最佳算法。它并不总是正确的，事实上它极大地限制了我们的选择，但是对于这个项目来说，它已经足够好了。

当你准备好了，点击窗口标题栏中的火车按钮。几秒钟后-我们的数据非常小!-你会看到一些结果指标出现。我们关心的值叫做均方根误差，应该是180左右。这意味着平均而言，该模型能够预测建议的准确睡眠时间，误差仅为180秒，即3分钟。

更好的是，如果你看右上角，你会看到一个MLModel图标说“输出”，它的文件大小约为438字节。Create ML使用了180KB的数据，并将其压缩到只有438个字节——几乎没有。

现在，438字节听起来很小，我知道，但值得补充的是，几乎所有这些字节都是元数据:作者的名字在那里，这是默认的描述“一个为回归而训练的机器学习模型”。它甚至对所有字段的名称进行编码:wake、estimatedSleep、coffee和actualSleep。

硬数据实际占用的空间量——如何根据我们的三个变量预测所需的睡眠量——远远小于100字节。这是可能的，因为Create ML实际上并不关心值是什么，它只关心关系是什么。因此，它花费了数十亿个CPU周期来尝试每个特性的不同权重组合，以确定哪个特性产生的值与实际目标值最接近，一旦它知道了最佳算法，它就会简单地将其存储起来。

现在我们的模型已经训练好了，我希望您将这个图标从Create ML拖到您的桌面，这样我们就可以在代码中使用它了。

提示:如果你想再次尝试训练——也许是尝试我们可用的各种算法——点击创建ML窗口右下角的Make A Copy。
